---
title: "JoesFlow"
output: md_document
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


The goal of JoesFlow is to analyze high-dimensional single cell data from flow cytometry, scRNA-seq, CITE-seq and any kind of single cell matrix data. JoesFlow utilizes novel scRNA-seq dimension reduction techniques to generate interpretable and informative visualizations that incorporate all aspects of a dataset in an unbiased manner.

```{r libs, echo=FALSE, message=FALSE, results='hide'}
library(RColorBrewer) # brewer.pal
library(ggsci) # pal_d3, pal_igv
library(ggplot2)
library(ggrepel)
library(reshape2)
library(gridExtra) # grid.arrange, arangeGrob
library(uwot)
library(ComplexHeatmap)
library(circlize)

library(JoesFlow)

library(dplyr)

colors_clusters = c(pal_d3("category10")(10), pal_d3("category20b")(20), pal_igv("default")(51))
colors_samples = c(brewer.pal(5, "Set1"), brewer.pal(8, "Dark2"), pal_igv("default")(51))

```


## JoesFlow Installation

Install locally in RStudio
``` {r install, eval=FALSE}
remotes::install_github("jcooperdevlin/JoesFlow")
```

```{r setup, eval=FALSE}
library(JoesFlow)
run_app()
#> Loading required package: shiny
#> 
#> Attaching package: 'shiny'
#> The following objects are masked from 'package:DT':
#> 
#>     dataTableOutput, renderDataTable
#> 
#> Listening on http://127.0.0.1:6897
```

![Joe's Flow Screenshot](README_files/setup-1.png)

## JoesFlow Functions

```{r test_data}
sample_data=read.csv("tests/flow_test.csv", sep=',', header=T)
meta_data=read.csv("tests/metadata.csv", header=T, sep=',')
```

```{r test_data output1, eval=FALSE}
datatable(sample_data[1:100,1:20])
```

![sample_data table](README_files/test_data-1.png)

```{r test_data output2, eval=FALSE}
datatable(meta_data)
```

![meta_data table](README_files/test_data-2.png)

```{r pca_source, echo=FALSE}

composition_plot=function(data, meta, k) {
  data_mat2=data[,-1]
  ids=data[,1]
  data_mat2=data.matrix(data_mat2)

  kmeaner=kmeans(data_mat2, k)
  kk=paste0("C", kmeaner$cluster)
  
  kmeans=as.character(kk)
    
  totaler=data.frame(table(ids))
  k_df = data.frame(table(kmeans, ids))
  k_mat = dcast(k_df, ids ~ kmeans)
  
  k_mat=k_mat[,-1]
  k_add=apply(k_mat, 2, function(x){(x/totaler$Freq)*100})
  
  plotter=data.frame(k_add, SampleID=totaler$ids)
  
  plotter$Group=as.character(plotter$SampleID)
  samps=as.character(unique(plotter$SampleID))
  for(jj in 1:length(samps)){
    grouper=subset(meta, ID==samps[jj])
    grouper=as.character(grouper$Group[1])
    
    plotter$Group[plotter$SampleID==samps[jj]]<-grouper
  }
  plotter_melt=melt(data=plotter, id.vars=c("SampleID", "Group"))
      
  k_cols=length(unique(plotter_melt$Group))
  colors_use = c(colors_clusters[1:k_cols], colors_samples)
  
  g1=ggplot(plotter_melt, aes(SampleID, value, fill=variable)) + 
    #geom_tile(aes(x=SampleID,y=105,fill=Group, height=5), show.legend = F) +
    geom_col()+ scale_fill_manual(values=colors_clusters) + theme_bw() +
    guides(fill = guide_legend("Cluster")) + ylab("Cluster Percentage %") +
    theme(axis.text=element_text(color='black', size=14),
          axis.title=element_text(color='black', size=16)) +
    facet_wrap(~Group, ncol=k_cols, scales="free")
  grid.arrange(g1)
  total_col=ncol(plotter)
  #datatable(data.frame(plotter[,(total_col-1):total_col], plotter[,1:(total_col-2)]))
}
```

```{r pca, fig.height = 5, fig.width = 12, fig.align = "center"}

# PCA cluster
pp <- select(sample_data, -SampleID) %>%
  prcomp(scale=T)
  
pc1 <- clusterJF(pp, ids = sample_data$SampleID, 
            meta = meta_data$Group, 
            colors = colors_samples)
 
# Kmeans cluster
set.seed(23948)
kmeans_groups <- select(sample_data, -SampleID) %>%
  kmeans(10) %$% cluster %>%
  {paste0('C', .)} # add a 'C' on the front of each group
  
pc2 <- clusterJF(pp, ids = 1:nrow(sample_data),
                 meta = kmeans_groups,
                 colors = colors_clusters,
                 legend.name = 'Kmeans')

# add these in their own section below to avoid repeating the same thing over and over again
# Figure out what purpose this serves...
# # sample-based pca
# groups_table <- with(sample_data, table(SampleID, kmeans_groups))
# 
# pp <- apply(groups_table, 2, function(x) x / rowSums(groups_table)) %>%
#   prcomp()
# 
# gg3 <- sb_clusterJF(pp, ids = rownames(groups_table),
#                     meta = meta_data$Group,
#                     colors = colors_samples)
# 
# # loadings
# gg4 <- sb_loadingsJF(pp, colors = colors_clusters)

grid.arrange(pc1, pc2, nrow=1)
```

```{r umap, fig.height = 5, fig.width = 12, fig.align = "center"}

# Umap
mnist_umap <- select(sample_data, -SampleID) %>%
  umap(pca = 15, fast_sgd = TRUE)

um1 <- clusterJF(mnist_umap, ids = sample_data$SampleID,
                 meta = meta_data$Group,
                 colors = colors_samples)

um2 <- clusterJF(mnist_umap, ids = 1:nrow(sample_data),
                 meta = kmeans_groups,
                 colors = colors_clusters,
                 legend.name = 'Kmeans')

grid.arrange(um1, um2, nrow=1)
```

```{r comp_plot, fig.height = 6, fig.width = 8, fig.align = "center"}

composition_plot(sample_data, meta_data, 15)

```

![data table](README_files/comp_plot-2.png)

```{r heat_plot, fig.height = 10, fig.width = 12, fig.align = "center"}
# marker heat plot
select(sample_data, -SampleID) %>%
  marker_heatJF(ids = sample_data$SampleID,
                meta = meta_data$Group,
                colors = colors_samples,
                sample_size = 500)
```